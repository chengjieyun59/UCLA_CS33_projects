Bomb lab:
ssh jieyun@lnxsrv01.seas.ucla.edu
cd bomb150
after getting to: [jieyun@lnxsrv01 ~/bomb150]$



////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                              Phase 1                                               //
////////////////////////////////////////////////////////////////////////////////////////////////////////

gdb bomb
break explode_bomb
break phase_1
(Just set breakpoints at whichever phase we’re at)

run
(gdb outputs:
Starting program: /w/home.05/ee/ugrad/jieyun/bomb150/bomb 
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!)

test (this became my input string)
(gdb outputs:
Breakpoint 2, 0x0000000000401268 in phase_1 ()
Missing separate debuginfos, use: debuginfo-install glibc-2.12-1.209.el6_9.2.x86_64)

(gdb) disassemble
Dump of assembler code for function phase_1:
=> 0x0000000000401268 <+0>:	sub    $0x8,%rsp
   0x000000000040126c <+4>:	mov    $0x402448,%esi                // realized later that this address is the key!!!!!!!
   0x0000000000401271 <+9>:	callq  0x4012ac <strings_not_equal>  // call strings_not_equal function
   0x0000000000401276 <+14>:	test   %eax,%eax                     // compare &
   0x0000000000401278 <+16>:	je     0x40127f <phase_1+23>
   0x000000000040127a <+18>:	callq  0x401496 <explode_bomb>
   0x000000000040127f <+23>:	add    $0x8,%rsp
   0x0000000000401283 <+27>:	retq   
End of assembler dump.)

print/x $eax 
(gdb returns 0x603de0)

x/30s 0x603de0 
(x/NumberOfUnitsNeededs address)
(gdb print string value
s for string, c for character
gdb returns:
0x603de0 <input_strings>:	 "test"
0x603de5 <input_strings+5>:	 ""
0x603de6 <input_strings+6>:	 ""
…
0x603dfa <input_strings+26>:	 “”)

q 
(to quit)

x 0x603de0 
(gdb returns:
0x603de0 <input_strings>:	0x74736574)
(0x74 73 65 74 = t s e t. Inverted: t e s t)

(Didn’t find anything besides that %eax stores my input string of “test”. Now look into the “strings_not_equal” function by stepping through the assembly code in gdb)

stepi 3 (step through 3 instructions, so it goes right into strings_not_equal function)
disassemble
(gdb prints:
Dump of assembler code for function strings_not_equal:
=> 0x00000000004012ac <+0>:	push   %r12
   0x00000000004012ae <+2>:	push   %rbp
   0x00000000004012af <+3>:	push   %rbx
   0x00000000004012b0 <+4>:	mov    %rdi,%rbx
   0x00000000004012b3 <+7>:	mov    %rsi,%rbp
   0x00000000004012b6 <+10>:	callq  0x401290 <string_length>
   0x00000000004012bb <+15>:	mov    %eax,%r12d
   0x00000000004012be <+18>:	mov    %rbp,%rdi
   0x00000000004012c1 <+21>:	callq  0x401290 <string_length>
   0x00000000004012c6 <+26>:	cmp    %eax,%r12d
   0x00000000004012c9 <+29>:	jne    0x4012f1 <strings_not_equal+69>
   0x00000000004012cb <+31>:	movzbl (%rbx),%edx
   0x00000000004012ce <+34>:	test   %dl,%dl
   0x00000000004012d0 <+36>:	je     0x4012f8 <strings_not_equal+76>
   0x00000000004012d2 <+38>:	mov    %rbp,%rax
   0x00000000004012d5 <+41>:	cmp    0x0(%rbp),%dl
   0x00000000004012d8 <+44>:	je     0x4012e4 <strings_not_equal+56>
   0x00000000004012da <+46>:	jmp    0x4012f1 <strings_not_equal+69>
   0x00000000004012dc <+48>:	add    $0x1,%rax
   0x00000000004012e0 <+52>:	cmp    (%rax),%dl
   0x00000000004012e2 <+54>:	jne    0x4012f1 <strings_not_equal+69>
   0x00000000004012e4 <+56>:	add    $0x1,%rbx
---Type <return> to continue, or q <return> to quit—)

print/x $eax (gdb prints: $2 = 0x0)
x 0x0
0x0:	Cannot access memory at address 0x0
(gdb) print/x $rbp
$2 = 0x0
(gdb) x 0x0
0x0:	Cannot access memory at address 0x0
(gdb) print/x $dl
$6 = 0x0
(gdb) x 0x0
0x0:	Cannot access memory at address 0x0

(gdb) print/x $r12d
$7 = 0x400c50
(gdb) x 0x400c50
0x400c50 <_start>:	0x31
(gdb) print/x $eax
$8 = 0x603de0
(gdb) x 0x603de0
0x603de0 <input_strings>:	0x62

(turns out that the first disassemble result had the important information:
   0x000000000040126c <+4>:	mov    $0x402448,%esi)

x/50s 0x402448
(gdb outputs: 0x402448 <__dso_handle+384>:	 "I am for medical liability at the federal level.”)

q (to quit)
./bomb
I am for medical liability at the federal level.
(then close the terminal window to quit.)



////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                              Phase 2                                               //
////////////////////////////////////////////////////////////////////////////////////////////////////////

gdb bomb
break explode_bomb
break phase_2
run
I am for medical liability at the federal level.
test

disassemble 
(gdb outputs:
Dump of assembler code for function phase_2:
=> 0x000000000040104d <+0>:	push   %rbp
   0x000000000040104e <+1>:	push   %rbx
   0x000000000040104f <+2>:	sub    $0x28,%rsp
   0x0000000000401053 <+6>:	mov    %rsp,%rsi
   0x0000000000401056 <+9>:	callq  0x4014cc <read_six_numbers>  // call read_six_numbers function
   0x000000000040105b <+14>:	cmpl   $0x1,(%rsp)                  // compare %rsp to 1
   0x000000000040105f <+18>:	jne    0x401068 <phase_2+27>        // or bomb will explode
   0x0000000000401061 <+20>:	cmpl   $0x2,0x4(%rsp)
   0x0000000000401066 <+25>:	je     0x40106d <phase_2+32>
   0x0000000000401068 <+27>:	callq  0x401496 <explode_bomb>
   0x000000000040106d <+32>:	mov    %rsp,%rbp
   0x0000000000401070 <+35>:	lea    0x8(%rsp),%rbx               // rsp gets incremented by 8
   0x0000000000401075 <+40>:	add    $0x18,%rbp
   0x0000000000401079 <+44>:	mov    -0x4(%rbx),%eax
   0x000000000040107c <+47>:	add    -0x8(%rbx),%eax
   0x000000000040107f <+50>:	cmp    %eax,(%rbx)                  // compare %eax to %rbx. Step until here
   0x0000000000401081 <+52>:	je     0x401088 <phase_2+59>        // jump
   0x0000000000401083 <+54>:	callq  0x401496 <explode_bomb>
   0x0000000000401088 <+59>:	add    $0x4,%rbx
   0x000000000040108c <+63>:	cmp    %rbp,%rbx                    // compare
   0x000000000040108f <+66>:	jne    0x401079 <phase_2+44>        // or bomb will explode
   0x0000000000401091 <+68>:	add    $0x28,%rsp
---Type <return> to continue, or q <return> to quit---)

return
(gdb outputs:
   0x0000000000401095 <+72>:	pop    %rbx
   0x0000000000401096 <+73>:	pop    %rbp
   0x0000000000401097 <+74>:	retq   
End of assembler dump.)

stepi 5
(gdb outputs:
0x00000000004014cc in read_six_numbers ())

disassemble
(gdb outputs:
Dump of assembler code for function read_six_numbers:
=> 0x00000000004014cc <+0>:	sub    $0x18,%rsp
   0x00000000004014d0 <+4>:	mov    %rsi,%rdx
   0x00000000004014d3 <+7>:	lea    0x4(%rsi),%rcx
   0x00000000004014d7 <+11>:	lea    0x14(%rsi),%rax
   0x00000000004014db <+15>:	mov    %rax,0x8(%rsp)
   0x00000000004014e0 <+20>:	lea    0x10(%rsi),%rax
   0x00000000004014e4 <+24>:	mov    %rax,(%rsp)
   0x00000000004014e8 <+28>:	lea    0xc(%rsi),%r9
   0x00000000004014ec <+32>:	lea    0x8(%rsi),%r8
   0x00000000004014f0 <+36>:	mov    $0x402590,%esi
   0x00000000004014f5 <+41>:	mov    $0x0,%eax
   0x00000000004014fa <+46>:	callq  0x400ac8 <__isoc99_sscanf@plt>
   0x00000000004014ff <+51>:	cmp    $0x5,%eax
   0x0000000000401502 <+54>:	jg     0x401509 <read_six_numbers+61>
   0x0000000000401504 <+56>:	callq  0x401496 <explode_bomb>
   0x0000000000401509 <+61>:	add    $0x18,%rsp
   0x000000000040150d <+65>:	retq   
End of assembler dump.)

(Since phase 2 should take 6 numbers, instead of “test”, I’ll try typing “10 20 30 40 50 60” instead.)
quit
gdb bomb
break explode_bomb
break phase_2

(Make a txt file called “defuseBomb.txt” with this inside, including a blank 3rd line:
I am for medical liability at the federal level.
10 20 30 40 50 60
)
(Put this text file into Cyberduck into my bomb150 folder.
Cyberduck: click “Open Connection”, select “SFTP”, type “lnxsrv.seas.ucla.edu” for Server, and my username and password, and click connect.)

run defuseBomb.txt
(gdb outputs:
Starting program: /w/home.05/ee/ugrad/jieyun/bomb150/bomb defuseBomb.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?

Breakpoint 2, 0x000000000040104d in phase_2 ())

disassemble
print/x $eax (gdb outputs: $1 = 0x603e30)
x/s 0x603e30 (gdb outputs: 0x603e30 <input_strings+80>:	 "10 20 30 40 50 60”)

Tried these, but didn’t find 6 numbers:
(gdb) print/x $rsp
$2 = 0x7fffffffe0d8
(gdb) x/s 0x7fffffffe0d8
0x7fffffffe0d8:	 "\356\r@"
(gdb) print/x $rsi
$3 = 0x50
(gdb) x/s 0x50
0x50:	 <Address 0x50 out of bounds>
(gdb) until *0x000000000040107c
Breakpoint 1, 0x0000000000401496 in explode_bomb ()

(gdb) next
Single stepping until exit from function explode_bomb,
which has no line number information.
Your instructor has been notified.

Program exited with code 010.

(… blew the bomb again, never use the “next” command.)

quit
gdb bomb
break explode_bomb
break phase_2
run
I am for medical liability at the federal level.
1 2 3 4 5 6
disassemble
(gdb outputs:
Dump of assembler code for function phase_2:
=> 0x000000000040104d <+0>:	push   %rbp
   0x000000000040104e <+1>:	push   %rbx
   0x000000000040104f <+2>:	sub    $0x28,%rsp
   0x0000000000401053 <+6>:	mov    %rsp,%rsi
   0x0000000000401056 <+9>:	callq  0x4014cc <read_six_numbers>
   0x000000000040105b <+14>:	cmpl   $0x1,(%rsp)                  // First: compare rsp to 1
   0x000000000040105f <+18>:	jne    0x401068 <phase_2+27>        // continue if > 1, otherwise explode
   0x0000000000401061 <+20>:	cmpl   $0x2,0x4(%rsp)
   0x0000000000401066 <+25>:	je     0x40106d <phase_2+32>
   0x0000000000401068 <+27>:	callq  0x401496 <explode_bomb>      // pass first bomb if first number is 1
   0x000000000040106d <+32>:	mov    %rsp,%rbp                    // rbp = rsp. Loop
   0x0000000000401070 <+35>:	lea    0x8(%rsp),%rbx               // rbx = 3rd number, rsp = 1st number
   0x0000000000401075 <+40>:	add    $0x18,%rbp                   // remove the room from stack
   0x0000000000401079 <+44>:	mov    -0x4(%rbx),%eax              // store the (rbx-1) number into eax
   0x000000000040107c <+47>:	add    -0x8(%rbx),%eax              // eax = (rbx-2)th number + eax. Like Fibonacci sequence. Key!!!!!!!
   0x000000000040107f <+50>:	cmp    %eax,(%rbx)                  // Second: compare rbx to eax
   0x0000000000401081 <+52>:	je     0x401088 <phase_2+59>
   0x0000000000401083 <+54>:	callq  0x401496 <explode_bomb>      // how to pass second bomb?
   0x0000000000401088 <+59>:	add    $0x4,%rbx                    // rbx = (rbx+1)th number
   0x000000000040108c <+63>:	cmp    %rbp,%rbx                    // See if it’s the last number. If so, end loop.
   0x000000000040108f <+66>:	jne    0x401079 <phase_2+44>        // if rbx is not equal to rbp, keep looping
   0x0000000000401091 <+68>:	add    $0x28,%rsp                   // remove the room from stack
   0x0000000000401095 <+72>:	pop    %rbx
   0x0000000000401096 <+73>:	pop    %rbp
   0x0000000000401097 <+74>:	retq   
End of assembler dump.)

nth number  | value
  1             1
  2             eax = prev + prev’s prev = 1 + 1 = 2
  3             eax = prev + prev’s prev = 2 + 1 = 3
  4             eax = prev + prev’s prev = 3 + 2 = 5
  5             eax = prev + prev’s prev = 5 + 3 = 8
  6             eax = prev + prev’s prev = 8 + 5 = 13

quit
./bomb
I am for medical liability at the federal level.
1 2 3 5 8 13
(then terminate the whole terminal window)



////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                              Phase 3                                               //
////////////////////////////////////////////////////////////////////////////////////////////////////////

gdb bomb
break explode_bomb
break phase_3
run
I am for medical liability at the federal level.
1 2 3 5 8 13
ummm

disassemble
(gdb outputs:
Dump of assembler code for function phase_3:
=> 0x000000000040112b <+0>:	sub    $0x18,%rsp
   0x000000000040112f <+4>:	lea    0x7(%rsp),%rcx
   0x0000000000401134 <+9>:	lea    0xc(%rsp),%rdx
   0x0000000000401139 <+14>:	lea    0x8(%rsp),%r8
   0x000000000040113e <+19>:	mov    $0x402479,%esi                // check what’s at this address
   0x0000000000401143 <+24>:	mov    $0x0,%eax
   0x0000000000401148 <+29>:	callq  0x400ac8 <__isoc99_sscanf@plt>
   0x000000000040114d <+34>:	cmp    $0x2,%eax
   0x0000000000401150 <+37>:	jg     0x401157 <phase_3+44>
   0x0000000000401152 <+39>:	callq  0x401496 <explode_bomb>
   0x0000000000401157 <+44>:	cmpl   $0x7,0xc(%rsp)                //if first int > 7, explode. So first int <= 7
   0x000000000040115c <+49>:	ja     0x401240 <phase_3+277>
   0x0000000000401162 <+55>:	mov    0xc(%rsp),%eax                //eax = rsp
   0x0000000000401166 <+59>:	jmpq   *0x4024a0(,%rax,8)            //jump table. jumps to 0x40118f if first number is 1
   0x000000000040116d <+66>:	mov    $0x6e,%lax
   0x0000000000401172 <+71>:	cmpl   $0x80,0x8(%rsp)               //compare 0x80 with value stored at 0x8(%rsp), 0x80 = 8*16 = 128
   0x000000000040117a <+79>:	je     0x401258 <phase_3+301>
   0x0000000000401180 <+85>:	callq  0x401496 <explode_bomb>
   0x0000000000401185 <+90>:	mov    $0x6e,%eax
   0x000000000040118a <+95>:	jmpq   0x401258 <phase_3+301>        //jumps here if the first number inputted is 1
   0x000000000040118f <+100>:	mov    $0x6f,%eax                    //0x6f = ‘o’
   0x0000000000401194 <+105>:	cmpl   $0xc3,0x8(%rsp)               //(rsp) + 8 = 0xc3 = 12*16+3 = 195
   0x000000000040119c <+113>:	je     0x401258 <phase_3+301>        //if the second number equal to 195, jump to 0x401258
   0x00000000004011a2 <+119>:	callq  0x401496 <explode_bomb>
   0x00000000004011a7 <+124>:	mov    $0x6f,%eax
   0x00000000004011ac <+129>:	jmpq   0x401258 <phase_3+301>        //when first input is 2
   0x00000000004011b1 <+134>:	mov    $0x7a,%eax                    //0x7a = ‘z’
   0x00000000004011b6 <+139>:	cmpl   $0x35,0x8(%rsp)               //0x35 = 53
   0x00000000004011bb <+144>:	je     0x401258 <phase_3+301>
   0x00000000004011c1 <+150>:	callq  0x401496 <explode_bomb>
   0x00000000004011c6 <+155>:	mov    $0x7a,%eax
   0x00000000004011cb <+160>:	jmpq   0x401258 <phase_3+301>        //when first input is 3
   0x00000000004011d0 <+165>:	mov    $0x71,%eax                    //0x71 = ‘q’
   0x00000000004011d5 <+170>:	cmpl   $0x2c9,0x8(%rsp)              //0x2c9 = 713
   0x00000000004011dd <+178>:	je     0x401258 <phase_3+301>
   0x00000000004011df <+180>:	callq  0x401496 <explode_bomb>
   0x00000000004011e4 <+185>:	mov    $0x71,%eax                    //0x71 = ‘q’
   0x00000000004011e9 <+190>:	jmp    0x401258 <phase_3+301>        //when first input is 4
   0x00000000004011eb <+192>:	cmpl   $0x3ba,0x8(%rsp)              //0x3ba = 954
   0x00000000004011f3 <+200>:	je     0x40124c <phase_3+289>
   0x00000000004011f5 <+202>:	callq  0x401496 <explode_bomb>
   0x00000000004011fa <+207>:	mov    $0x6b,%eax                    //0x6b = ‘k’
   0x00000000004011ff <+212>:	jmp    0x401258 <phase_3+301>        //when first input is 5
   0x0000000000401201 <+214>:	cmpl   $0x73,0x8(%rsp)               //0x73 = 115
   0x0000000000401206 <+219>:	je     0x40124c <phase_3+289>
   0x0000000000401208 <+221>:	callq  0x401496 <explode_bomb>
   0x000000000040120d <+226>:	mov    $0x6b,%eax                    //0x6b = ‘k’
   0x0000000000401212 <+231>:	jmp    0x401258 <phase_3+301>        //when first input is 6
   0x0000000000401214 <+233>:	cmpl   $0x2a8,0x8(%rsp)              //0x2a8 = 680
   0x000000000040121c <+241>:	je     0x401253 <phase_3+296>
   0x000000000040121e <+243>:	callq  0x401496 <explode_bomb>
   0x0000000000401223 <+248>:	mov    $0x75,%eax                    //0x75 = ‘u’
   0x0000000000401228 <+253>:	jmp    0x401258 <phase_3+301>        //when first input is 7
   0x000000000040122a <+255>:	cmpl   $0x2e3,0x8(%rsp)              //0x2e3 = 739
   0x0000000000401232 <+263>:	je     0x401253 <phase_3+296>
   0x0000000000401234 <+265>:	callq  0x401496 <explode_bomb>
   0x0000000000401239 <+270>:	mov    $0x75,%eax                    //0x75 = ‘u’
   0x000000000040123e <+275>:	jmp    0x401258 <phase_3+301>
   0x0000000000401240 <+277>:	callq  0x401496 <explode_bomb>
   0x0000000000401245 <+282>:	mov    $0x64,%eax                    //0x64 = ‘d’
   0x000000000040124a <+287>:	jmp    0x401258 <phase_3+301>
   0x000000000040124c <+289>:	mov    $0x6b,%eax                    //0x6b = ‘k’
   0x0000000000401251 <+294>:	jmp    0x401258 <phase_3+301>
   0x0000000000401253 <+296>:	mov    $0x75,%eax                   // 0x75 = ‘u’
   0x0000000000401258 <+301>:	cmp    0x7(%rsp),%al                // jumped here. so char is the value in %al
   0x000000000040125c <+305>:	je     0x401263 <phase_3+312>
   0x000000000040125e <+307>:	callq  0x401496 <explode_bomb>
   0x0000000000401263 <+312>:	add    $0x18,%rsp
   0x0000000000401267 <+316>:	retq   
End of assembler dump.

// THE FORMAT IS THE SECOND TO LAST ARGUMENT TO SSCANF
(gdb) x/s 0x402479
0x402479 <__dso_handle+433>:	 "%d %c %d" // so it’s a decimal number, then a char, then a decimal number

quit gdb and try this input string: 1 a 195

(gdb) p/x $eax
$1 = 0x603e80
(gdb) x/s 0x603e80
0x603e80 <input_strings+160>:	 "1 a 195"

(gdb) p/x $al
$2 = 0x80
(gdb) x/s 0x80
0x80:	 <Address 0x80 out of bounds>

// LETS PRINT THE JUMP TABLE  (I ADDED SPACES TO THE DISAS ABOVE TO SHOW THE TABLE)
(gdb) b *0x0000000000401166
Breakpoint 3 at 0x401166
(gdb) c
Continuing.

Breakpoint 3, 0x0000000000401166 in phase_3 ()
(gdb) x/8x 0x4024a0
0x4024a0 <__dso_handle+472>:	0x6d	0x11	0x40	0x00	0x00	0x00	0x00	0x00
(gdb) x/8a 0x4024a0
0x4024a0 <__dso_handle+472>:	0x40116d <phase_3+66>	0x40118f <phase_3+100>
0x4024b0 <__dso_handle+488>:	0x4011b1 <phase_3+134>	0x4011d0 <phase_3+165>
0x4024c0 <__dso_handle+504>:	0x4011eb <phase_3+192>	0x401201 <phase_3+214>
0x4024d0 <__dso_handle+520>:	0x401214 <phase_3+233>	0x40122a <phase_3+255>

// Since my first integer was 1, it should go to address 0x40118f <phase_3+100> according to the jump table
(gdb) si
0x000000000040118f in phase_3 ()

Now I know one working answer would be “1 char 195”, where “char” is a letter.
p/x $al prints 0x80, which doesn’t translate to a char.
Since p/x $al didn’t work, try p/x $rsp
(gdb) p/x $rsp
$1 = 0x7fffffffe0e8
0xe8 also didn’t work.
Check the lines before that.
eax = 0x75, so the char should be ‘u’.

Try answer:
1 u 195

quit
./bomb
I am for medical liability at the federal level.
1 2 3 5 8 13
1 u 195
(then terminate the whole terminal window)
BOOM!!!
The bomb has blown up.
Your instructor has been notified.

Try: 1 o 195
Worked!
There should be 7 answers that would work:
1 o 195
2 z 53
3 q 713
4 q 954
5 k 115
6 k 680
7 u 739



////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                              Phase 4                                               //
////////////////////////////////////////////////////////////////////////////////////////////////////////
gdb bomb
break explode_bomb
break phase_4
run bombDefusingAns.txt
60 3
disassemble

Dump of assembler code for function phase_4:
=> 0x00000000004010d8 <+0>:	sub    $0x18,%rsp
   0x00000000004010dc <+4>:	lea    0xc(%rsp),%rcx
   0x00000000004010e1 <+9>:	lea    0x8(%rsp),%rdx
   0x00000000004010e6 <+14>:	mov    $0x40259c,%esi                  // check what form the input should be
   0x00000000004010eb <+19>:	mov    $0x0,%eax
   0x00000000004010f0 <+24>:	callq  0x400ac8 <__isoc99_sscanf@plt>
   0x00000000004010f5 <+29>:	cmp    $0x2,%eax                       // check if my input string is in %eax. eax cannot be 2
   0x00000000004010f8 <+32>:	jne    0x401108 <phase_4+48>           // jump to explode bomb, if the input doesn’t have 2 values
   0x00000000004010fa <+34>:	mov    0xc(%rsp),%eax                  // eax = rsp
   0x00000000004010fe <+38>:	cmp    $0x1,%eax                       // compare eax to 1
   0x0000000000401101 <+41>:	jle    0x401108 <phase_4+48>           // jump to explode bomb if eax <= 1
   0x0000000000401103 <+43>:	cmp    $0x4,%eax                       // compare eax to 4
   0x0000000000401106 <+46>:	jle    0x40110d <phase_4+53>           // jump to AFTER explode bomb if eax <= 4
   0x0000000000401108 <+48>:	callq  0x401496 <explode_bomb>
   0x000000000040110d <+53>:	mov    0xc(%rsp),%esi                  // esi = rsp = a1, second parameter taken in by func4
   0x0000000000401111 <+57>:	mov    $0x6,%edi                       // edi = 6, first parameter taken in by func4
   0x0000000000401116 <+62>:	callq  0x400e70 <func4>                // call function func4 with parameters a1, 6
   0x000000000040111b <+67>:	cmp    0x8(%rsp),%eax                  // now compare eax to rsp. eax must be the value returned by func4
   0x000000000040111f <+71>:	je     0x401126 <phase_4+78>           // jump to AFTER explode bomb if eax = rsp
   0x0000000000401121 <+73>:	callq  0x401496 <explode_bomb>
   0x0000000000401126 <+78>:	add    $0x18,%rsp
   0x000000000040112a <+82>:	retq   
---Type <return> to continue, or q <return> to quit---return
End of assembler dump.

(gdb) x/s 0x40259c
0x40259c:	 "%d %d"
// the input should be 2 numbers. Input “9 16” instead
(gdb) p/x $eax
$1 = 0x603ed0
(gdb) x/s 0x603ed0
0x603ed0 <input_strings+240>:	 "9 16"
// going through the assembly code, the first number eax must be 3 or 4
// try input “3 16”

// See what value is in rsp to guess what the final eax is
(gdb) p/x $rsp
$2 = 0x7fffffffe0e8
(gdb) x/s 0x7fffffffe0e8
0x7fffffffe0e8:	 "&\016@"
// No clue was given
// step through the code
ni
// but hit the first explode_bomb break point, so quit gdb
// Try exchanging the first and second number. Now try “16 3”
// Now it passes the first check!

// Try to look into func4 by setting a breakpoint there
(gdb) b *0x0000000000401116
Breakpoint 3 at 0x401116
// keep stepping through the code multiple times until hitting func4
ni
// note: “ni” doesn’t go into a function, “si” goes into a function
(gdb) until *0x0000000000401116
Breakpoint 3, 0x0000000000401116 in phase_4 ()
(gdb) si
0x0000000000400e70 in func4 ()
(gdb) si
0x0000000000400e75 in func4 ()
(gdb) disassemble
Dump of assembler code for function func4:
   0x0000000000400e70 <+0>:	mov    %rbx,-0x18(%rsp)       // (rsp-18) = rbx
=> 0x0000000000400e75 <+5>:	mov    %rbp,-0x10(%rsp)       // (rsp-10) = rap
   0x0000000000400e7a <+10>:	mov    %r12,-0x8(%rsp)        // (rsp-8) = r12
   0x0000000000400e7f <+15>:	sub    $0x18,%rsp             // rsp = rsp - 0x18 = rsp - 24
   0x0000000000400e83 <+19>:	mov    %edi,%ebx              // ebx = edi
   0x0000000000400e85 <+21>:	mov    %esi,%ebp              // ebp = esi
   0x0000000000400e87 <+23>:	test   %edi,%edi              // if edi = 0?
   0x0000000000400e89 <+25>:	jg     0x400e92 <func4+34>    // jump to [1]0x400e92 when greater than
   0x0000000000400e8b <+27>:	mov    $0x0,%ebp              // ebp = 0
   0x0000000000400e90 <+32>:	jmp    0x400eb2 <func4+66>    // jump to [2]
   0x0000000000400e92 <+34>:	cmp    $0x1,%edi              // [1] compare edi to 1
   0x0000000000400e95 <+37>:	je     0x400eb2 <func4+66>    // jump to [2] if edi = 1
   0x0000000000400e97 <+39>:	lea    -0x1(%rbx),%edi        // copy edi’s address into rbi’s address
   0x0000000000400e9a <+42>:	callq  0x400e70 <func4>       // call func4 recursively
   0x0000000000400e9f <+47>:	mov    %eax,%r12d             // r12d = eax
   0x0000000000400ea2 <+50>:	lea    -0x2(%rbx),%edi        // copy edi’s address into rbx’s address
   0x0000000000400ea5 <+53>:	mov    %ebp,%esi              // esi = ebp
   0x0000000000400ea7 <+55>:	callq  0x400e70 <func4>       // call func4 recursively
   0x0000000000400eac <+60>:	add    %eax,%r12d             // r12d = r12d + eax
   0x0000000000400eaf <+63>:	add    %r12d,%ebp             // ebp = ebp + r12d
   0x0000000000400eb2 <+66>:	mov    %ebp,%eax              // [2] eax = ebp
   0x0000000000400eb4 <+68>:	mov    (%rsp),%rbx            // rbx = rsp
   0x0000000000400eb8 <+72>:	mov    0x8(%rsp),%rbp         // rbp = rsp
   0x0000000000400ebd <+77>:	mov    0x10(%rsp),%r12        // r12 = rsp
   0x0000000000400ec2 <+82>:	add    $0x18,%rsp             // rsp = rsp + 0x18 = rsp + 24
   0x0000000000400ec6 <+86>:	retq   
End of assembler dump.

// Since I know what parameter values go into the function, 
// I don’t necessarily have to figure out what the function does.
// I just need to know what it returns, and that will be the first number.
// retry with “16 3” and disassemble
(gdb) until *0x0000000000401111
0x0000000000401111 in phase_4 ()
(gdb) p/x $esi
$1 = 0x3
(gdb) p func4(6, 3)
$2 = 60
// 60 is the number returned

kill // using this keeps all the breakpoints. Better than “quit” in this case
run // automatically finishes previous phases that I already defused
60 3
continue
So you got that one.  Try this one.
// Now save “60 3” in the next line in bombDefusingAns.txt
// Upload through Cyberduck

quit
./bomb
I am for medical liability at the federal level.
1 2 3 5 8 13
1 o 195
60 3



////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                              Phase 5                                               //
////////////////////////////////////////////////////////////////////////////////////////////////////////
gdb bomb
break explode_bomb
break phase_5
run bombDefusingAns.txt
abcdef
disassemble

Dump of assembler code for function phase_5:
=> 0x0000000000401098 <+0>:	push   %rbx
   0x0000000000401099 <+1>:	mov    %rdi,%rbx                 // rbx = rbi
   0x000000000040109c <+4>:	callq  0x401290 <string_length>  // call function string_length
   0x00000000004010a1 <+9>:	cmp    $0x6,%eax                 // input string eax needs to be of size 6. Try “abcdef”
   0x00000000004010a4 <+12>:	je     0x4010ab <phase_5+19>     // jump to [1] if equal
   0x00000000004010a6 <+14>:	callq  0x401496 <explode_bomb>
   0x00000000004010ab <+19>:	lea    0x6(%rbx),%rsi            // [1] 
   0x00000000004010af <+23>:	mov    $0x0,%eax                 // eax = 0
   0x00000000004010b4 <+28>:	mov    $0x4024e0,%edx            // 
   0x00000000004010b9 <+33>:	movsbq (%rbx),%rcx               // [2] LOOP STARTS HERE
   0x00000000004010bd <+37>:	and    $0xf,%ecx                 // perform binary AND operation between 0xf and ecx
   0x00000000004010c0 <+40>:	add    (%rdx,%rcx,4),%eax        // perform binary AND operation between rcx*4+rdx and eax
   0x00000000004010c3 <+43>:	add    $0x1,%rbx                 // rbx = rbx + 1
   0x00000000004010c7 <+47>:	cmp    %rsi,%rbx                 // compare rbx to rsi
   0x00000000004010ca <+50>:	jne    0x4010b9 <phase_5+33>     // jump to [2] if not equal. LOOP ENDS HERE
   0x00000000004010cc <+52>:	cmp    $0x45,%eax                // compare eax to 0x45 = 69
   0x00000000004010cf <+55>:	je     0x4010d6 <phase_5+62>     // jump to AFTER explode_bomb if equal
   0x00000000004010d1 <+57>:	callq  0x401496 <explode_bomb>
   0x00000000004010d6 <+62>:	pop    %rbx
   0x00000000004010d7 <+63>:	retq   
End of assembler dump.

// check if eax is indeed the register containing the input string
(gdb) p/x $eax
$1 = 0x603f20
(gdb) x/s 0x603f20
0x603f20 <input_strings+320>:	 "abcdef"

// Step to right before the loop
(gdb) until *0x4010b4

(gdb) stepi 5
0x00000000004010c7 in phase_5 ()
(gdb) disas
Dump of assembler code for function phase_5:
   0x0000000000401098 <+0>:	push   %rbx
   0x0000000000401099 <+1>:	mov    %rdi,%rbx
   0x000000000040109c <+4>:	callq  0x401290 <string_length>
   0x00000000004010a1 <+9>:	cmp    $0x6,%eax
   0x00000000004010a4 <+12>:	je     0x4010ab <phase_5+19>
   0x00000000004010a6 <+14>:	callq  0x401496 <explode_bomb>
   0x00000000004010ab <+19>:	lea    0x6(%rbx),%rsi
   0x00000000004010af <+23>:	mov    $0x0,%eax
   0x00000000004010b4 <+28>:	mov    $0x4024e0,%edx
   0x00000000004010b9 <+33>:	movsbq (%rbx),%rcx
   0x00000000004010bd <+37>:	and    $0xf,%ecx
   0x00000000004010c0 <+40>:	add    (%rdx,%rcx,4),%eax
   0x00000000004010c3 <+43>:	add    $0x1,%rbx
=> 0x00000000004010c7 <+47>:	cmp    %rsi,%rbx
   0x00000000004010ca <+50>:	jne    0x4010b9 <phase_5+33>
   0x00000000004010cc <+52>:	cmp    $0x45,%eax
   0x00000000004010cf <+55>:	je     0x4010d6 <phase_5+62>
   0x00000000004010d1 <+57>:	callq  0x401496 <explode_bomb>
   0x00000000004010d6 <+62>:	pop    %rbx
   0x00000000004010d7 <+63>:	retq   
End of assembler dump.

(gdb) i r
rax            0x6	6
rbx            0x603f21	6307617
rcx            0x1	1                    // first letter ‘a’ gives 0x1 = 1
rdx            0x4024e0	4203744
rsi            0x603f26	6307622
rdi            0x603f20	6307616
rbp            0x7fffffffe1d0	0x7fffffffe1d0
rsp            0x7fffffffe0c0	0x7fffffffe0c0
r8             0x380bf906b0	240719038128
r9             0x7ffff7fd4700	140737353959168
r10            0x22	34
r11            0x246	582
r12            0x400c50	4197456
r13            0x7fffffffe1c0	140737488347584
r14            0x0	0
r15            0x0	0
rip            0x4010c7	0x4010c7 <phase_5+47>
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

(gdb) stepi 6
0x00000000004010c7 in phase_5 ()
(gdb) i r
rax            0x10	16
rbx            0x603f22	6307618
rcx            0x2	2                    // second letter ‘b’ gives 0x2 = 2
rdx            0x4024e0	4203744
rsi            0x603f26	6307622
rdi            0x603f20	6307616
rbp            0x7fffffffe1d0	0x7fffffffe1d0
rsp            0x7fffffffe0c0	0x7fffffffe0c0
r8             0x380bf906b0	240719038128
r9             0x7ffff7fd4700	140737353959168
r10            0x22	34
r11            0x246	582
r12            0x400c50	4197456
r13            0x7fffffffe1c0	140737488347584
r14            0x0	0
r15            0x0	0
rip            0x4010c7	0x4010c7 <phase_5+47>
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

(gdb) stepi 6
0x00000000004010c7 in phase_5 ()
(gdb) i r $rcx
rcx            0x3	3                    // ‘c’ gives 0x3 = 3
(gdb) stepi 6
0x00000000004010c7 in phase_5 ()
(gdb) i r $rcx
rcx            0x4	4                    // ‘d’ gives 0x4 = 4
(gdb) stepi 6
0x00000000004010c7 in phase_5 ()
(gdb) i r $rcx
rcx            0x5	5                    // ‘e’ gives 0x5 = 5
(gdb) stepi 6
0x00000000004010c7 in phase_5 ()
(gdb) i r $rcx
rcx            0x6	6                    // ‘f’ gives 0x6 = 6
(gdb) stepi 6
Breakpoint 1, 0x0000000000401496 in explode_bomb ()

kill
run
ghijkl
until *0x4010c7
// do the two commands below and record each alphabet that maps to each decimal number
i r $rcx
stepi 6

a = 1
b = 2
c = 3
d = 4
e = 5
f = 6
g = 7
h = 8
i = 9
j = 10
k = 11
l = 12
. . .
u = 5
v = 6
w = 7
x = 8
y = 9 = 25%16
z = 10 = 26%16

The number repeats every 16 alphabets.

Sum to 69
69 = 11*5 + 14
= eeeeen

// “eeeeen” didn’t work. Try looking at eax value when it’s being compared to 0x45.
kill
y
run
eeeeen
until *0x4010cc
i r $eax
eax            0x5f	95

so eeeeen gives 95, instead of 69.

Seems like the real value for each alphabet wasn’t like that. Then find the actual value to each alphabet creates after going through the loop 6 times.
Try aaaaaa instead.
aaaaaa = 36 = 6 * 6
Maybe it’s multiplying value 1 by 6, and adding that repeatedly by 6 times.

bbbbbb = 60 = 6 * 10
So for each of the 6 loops, 2 may be changed to 10?

cccccc = 6 = 6 * 1

dddddd = 72 = 6 * 12

eeeeee = 96 = 6 * 16

ffffff = 54 = 6 * 9

Now there should be enough numbers that add to 69. Find a combination of letters that add to 69.
16 + 16 + 16 + 6 + 6 + 9 = 69
e    e    e    a   a   f

Worked!

// Now save “eeeaaf” in the next line in bombDefusingAns.txt
// Upload through Cyberduck

quit
y
./bomb
I am for medical liability at the federal level.
1 2 3 5 8 13
1 o 195
60 3
eeeaaf



////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                              Phase 6                                               //
////////////////////////////////////////////////////////////////////////////////////////////////////////
gdb bomb
break explode_bomb
break phase_6
run bombDefusingAns.txt
1 2 3 4 5 6
disassemble

Dump of assembler code for function phase_6:
=> 0x0000000000400f52 <+0>:	push   %r12
   0x0000000000400f54 <+2>:	push   %rbp
   0x0000000000400f55 <+3>:	push   %rbx
   0x0000000000400f56 <+4>:	sub    $0x50,%rsp
   0x0000000000400f5a <+8>:	lea    0x30(%rsp),%rbp
   0x0000000000400f5f <+13>:	mov    %rbp,%rsi
   0x0000000000400f62 <+16>:	callq  0x4014cc <read_six_numbers>     // need to input 6 numbers

   0x0000000000400f67 <+21>:	mov    $0x0,%r12d
   0x0000000000400f6d <+27>:	mov    0x0(%rbp),%eax
   0x0000000000400f70 <+30>:	sub    $0x1,%eax
   0x0000000000400f73 <+33>:	cmp    $0x5,%eax                       // the 6 numbers should all be <= 6
   0x0000000000400f76 <+36>:	jbe    0x400f7d <phase_6+43>           // if not, bomb will explode
   0x0000000000400f78 <+38>:	callq  0x401496 <explode_bomb>

   0x0000000000400f7d <+43>:	add    $0x1,%r12d
   0x0000000000400f81 <+47>:	cmp    $0x6,%r12d
   0x0000000000400f85 <+51>:	je     0x400fa9 <phase_6+87>
   0x0000000000400f87 <+53>:	mov    %r12d,%ebx
   0x0000000000400f8a <+56>:	movslq %ebx,%rax
   0x0000000000400f8d <+59>:	mov    0x0(%rbp),%edx
   0x0000000000400f90 <+62>:	cmp    0x30(%rsp,%rax,4),%edx          // make sure no 2 numbers are the same
   0x0000000000400f94 <+66>:	jne    0x400f9b <phase_6+73>           // if not, bomb will explode
   0x0000000000400f96 <+68>:	callq  0x401496 <explode_bomb>

   0x0000000000400f9b <+73>:	add    $0x1,%ebx                       // increment the count
   0x0000000000400f9e <+76>:	cmp    $0x5,%ebx                       // loops 6 times
   0x0000000000400fa1 <+79>:	jle    0x400f8a <phase_6+56>
   0x0000000000400fa3 <+81>:	add    $0x4,%rbp
   0x0000000000400fa7 <+85>:	jmp    0x400f6d <phase_6+27>
   0x0000000000400fa9 <+87>:	mov    $0x0,%ebx
   0x0000000000400fae <+92>:	lea    0x30(%rsp),%r8
   0x0000000000400fb3 <+97>:	mov    $0x1,%ebp
   0x0000000000400fb8 <+102>:	mov    $0x6037b0,%esi                  // Check this address. 0x6037b0
   0x0000000000400fbd <+107>:	mov    %rsp,%rdi
   0x0000000000400fc0 <+110>:	jmp    0x400fdb <phase_6+137>
   0x0000000000400fc2 <+112>:	mov    0x8(%rdx),%rdx
   0x0000000000400fc6 <+116>:	add    $0x1,%eax
   0x0000000000400fc9 <+119>:	cmp    %ecx,%eax
   0x0000000000400fcb <+121>:	jne    0x400fc2 <phase_6+112>
   0x0000000000400fcd <+123>:	mov    %rdx,(%rdi,%rbx,2)
   0x0000000000400fd1 <+127>:	add    $0x4,%rbx
   0x0000000000400fd5 <+131>:	cmp    $0x18,%rbx
   0x0000000000400fd9 <+135>:	je     0x400feb <phase_6+153>
   0x0000000000400fdb <+137>:	mov    (%r8,%rbx,1),%ecx
   0x0000000000400fdf <+141>:	mov    %ebp,%eax
   0x0000000000400fe1 <+143>:	mov    %rsi,%rdx
   0x0000000000400fe4 <+146>:	cmp    $0x1,%ecx
   0x0000000000400fe7 <+149>:	jg     0x400fc2 <phase_6+112>
   0x0000000000400fe9 <+151>:	jmp    0x400fcd <phase_6+123>
   0x0000000000400feb <+153>:	mov    (%rsp),%rbx
   0x0000000000400fef <+157>:	mov    0x8(%rsp),%rax
   0x0000000000400ff4 <+162>:	mov    %rax,0x8(%rbx)
   0x0000000000400ff8 <+166>:	mov    0x10(%rsp),%rdx
   0x0000000000400ffd <+171>:	mov    %rdx,0x8(%rax)
   0x0000000000401001 <+175>:	mov    0x18(%rsp),%rax
   0x0000000000401006 <+180>:	mov    %rax,0x8(%rdx)
   0x000000000040100a <+184>:	mov    0x20(%rsp),%rdx
   0x000000000040100f <+189>:	mov    %rdx,0x8(%rax)
   0x0000000000401013 <+193>:	mov    0x28(%rsp),%rax
   0x0000000000401018 <+198>:	mov    %rax,0x8(%rdx)
   0x000000000040101c <+202>:	movq   $0x0,0x8(%rax)
   0x0000000000401024 <+210>:	mov    $0x0,%ebp
   0x0000000000401029 <+215>:	mov    0x8(%rbx),%rax                 // LOOP STARTS HERE
   0x000000000040102d <+219>:	mov    (%rbx),%edx                    // edx = rbx
   0x000000000040102f <+221>:	cmp    (%rax),%edx                    // make sure that edx >= rax
   0x0000000000401031 <+223>:	jge    0x401038 <phase_6+230>         // so that bomb will not explode
   0x0000000000401033 <+225>:	callq  0x401496 <explode_bomb>

   0x0000000000401038 <+230>:	mov    0x8(%rbx),%rbx                 // go to the next element
   0x000000000040103c <+234>:	add    $0x1,%ebp                      // increment the count
   0x000000000040103f <+237>:	cmp    $0x5,%ebp                      // loop 6 times
   0x0000000000401042 <+240>:	jne    0x401029 <phase_6+215>         // LOOP ENDS HERE
   0x0000000000401044 <+242>:	add    $0x50,%rsp
   0x0000000000401048 <+246>:	pop    %rbx
   0x0000000000401049 <+247>:	pop    %rbp
   0x000000000040104a <+248>:	pop    %r12
   0x000000000040104c <+250>:	retq   
End of assembler dump.

// There are 3 explode_bomb instances. To pass through the first 2, based on reasoning annotated above, the input should be the numbers 1 2 3 4 5 6 in a certain order. So there are currently 6! = 720 possibilities. Reasoning up till the 3rd explode_bomb may offer some insight about the order.

// Try to see what was being compared right before the 3rd explode_bomb.
// From lines <+219> and <+221>, I can tell that rbx needs to >= rax. 
until *0x40102f
i r

rax            0x6037a0	6305696                    // first value compared
rbx            0x6037b0	6305712                    // second value compared
rcx            0x6	6
rdx            0x6f	111
rsi            0x6037b0	6305712
rdi            0x7fffffffe060	140737488347232
rbp            0x0	0x0
rsp            0x7fffffffe060	0x7fffffffe060
r8             0x7fffffffe090	140737488347280
r9             0x100	256
r10            0xb	11
r11            0xb	11
r12            0x6	6
r13            0x7fffffffe1c0	140737488347584
r14            0x0	0
r15            0x0	0
rip            0x40102f	0x40102f <phase_6+221>
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

// So for an input of “1 2 3 4 5 6”, rbx > rax, so it wouldn’t pass the 3rd conditional check to jump to after the bomb.
// Check the values in rbx. And make sure that whatever comes next in the loop, the value is always getting smaller.

/* .................. Wrong approach start: .................. */
(gdb) x/3x $rbx
0x6037b0 <node1>:	0x6f	0x00	0x00
(gdb) x/3x *($rbx + 8)
0x6037a0 <node2>:	0xa1	0x00	0x00
(gdb) x/3x *(*($rbx + 8) + 8)
0x603790 <node3>:	0x10	0x01	0x00
(gdb) x/3x *(*(*($rbx + 8) + 8) + 8)
0x603780 <node4>:	0xb2	0x01	0x00
(gdb) x/3x *(*(*(*($rbx + 8) + 8) + 8) + 8)
0x603770 <node5>:	0x05	0x02	0x00
(gdb) x/3x *(*(*(*(*($rbx + 8) + 8) + 8) + 8) + 8)
0x603760 <node6>:	0xeb	0x00	0x00

// So <node1> to <node6> have the addresses 0x6f to 0xeb. Put them in order from largest to smallest.
0xeb <node6>
0xb2 <node4>
0xa1 <node2>
0x6f <node1>
0x10 <node3>
0x05 <node5>

// Try 6 4 2 1 3 5 as input string. Found out that whatever the order. These 6 addresses listed above for each node remain the same.
kill
y
run
6 4 2 1 3 5
until *0x40102f
i r

rax            0x603780	6305664
rbx            0x603760	6305632
// Step through with “si”, but didn’t pass the first iteration of explode bomb.

// Try to reverse the order.
5 3 1 2 4 6
(gdb) i r
rax            0x603790	6305680
rbx            0x603770	6305648
// Step through, but didn’t pass the 3rd iteration of explode bomb. So 5 3 are in correct order. So now I know for the node values, 5 > 3 and 4 > 6.

// Try 5 4 3 1 2 6. Step through, but didn’t pass the 4th iteration of explode bomb. So 5 4 3 are in correct order. So now I know for the node values, 5 > 4 > 3 and 4 > 6.
// Try 5 4 1 3 2 6. Didn’t pass the 3rd iteration. 
// Try 5 1 4 3 2 6. Didn’t pass the 2nd iteration.
// Try 1 5 4 3 2 6. Didn’t pass the 1st iteration.
// Weird. Step through and see all the rbx listed for each number.
i r
For 1:
rbx            0x6037b0	6305712

For 2:
rbx            0x6037a0	6305696

For 3:
rbx            0x603790	6305680

For 4:
rbx            0x603780	6305664

For 5:
rbx            0x603770	6305648

For 6:
rbx            0x603760	6305632
// Weird, they’re all in order, but neither “1 2 3 4 5 6“ nor “6 5 4 3 2 1“ worked.

/* .................. Wrong approach end: .................. */

kill gdb and start again.

/* .................. Correct approach start: ..................*/
until *0x40102f
0x000000000040102f in phase_6 ()
(gdb) i r
rax            0x603780	6305664
rbx            0x603770	6305648                 // see what’s inside rbx address.
rcx            0x1	1
rdx            0x205	517
rsi            0x6037b0	6305712
rdi            0x7fffffffe060	140737488347232
rbp            0x0	0x0
rsp            0x7fffffffe060	0x7fffffffe060
r8             0x7fffffffe090	140737488347280
r9             0x100	256
r10            0xb	11
r11            0xb	11
r12            0x6	6
r13            0x7fffffffe1c0	140737488347584
r14            0x0	0
r15            0x0	0
rip            0x40102f	0x40102f <phase_6+221>
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

// see many node addresses inside rbx address
(gdb) x/64bx 0x603770
0x603770 <node5>:	0x05	0x02	0x00	0x00	0x05	0x00	0x00	0x00
0x603778 <node5+8>:	0x80	0x37	0x60	0x00	0x00	0x00	0x00	0x00
0x603780 <node4>:	0xb2	0x01	0x00	0x00	0x04	0x00	0x00	0x00
0x603788 <node4+8>:	0x90	0x37	0x60	0x00	0x00	0x00	0x00	0x00
0x603790 <node3>:	0x10	0x01	0x00	0x00	0x03	0x00	0x00	0x00
0x603798 <node3+8>:	0x60	0x37	0x60	0x00	0x00	0x00	0x00	0x00
0x6037a0 <node2>:	0xa1	0x00	0x00	0x00	0x02	0x00	0x00	0x00
0x6037a8 <node2+8>:	0xb0	0x37	0x60	0x00	0x00	0x00	0x00	0x00

// Get node1 and node6 addresses too
(gdb) x/8bx 0x603760
0x603760 <node6>:	0xeb	0x00	0x00	0x00	0x06	0x00	0x00	0x00
(gdb) x/8bx 0x6037b0
0x6037b0 <node1>:	0x6f	0x00	0x00	0x00	0x01	0x00	0x00	0x00
(gdb) 

little endian, unsigned comparison
node 6 -> 00eb = 235
node 5 -> 0205 = 517
node 4 -> 01b2 = 434
node 3 -> 0110 = 272
node 2 -> 00a1 = 161
node 1 -> 006f = 111

// Sort from largest to smallest
517 > 434 > 272 > 235 > 161 > 111
5     4     3     6     2     1

// Kill gdb and retry this:
5 4 3 6 2 1

// Worked!!!

./bomb
I am for medical liability at the federal level.
1 2 3 5 8 13
1 o 195
60 3
eeeaaf
5 4 3 6 2 1



////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                          Phase 7 (Secret)                                          //
////////////////////////////////////////////////////////////////////////////////////////////////////////

[jieyun@lnxsrv01 ~/bomb150]$ objdump -d bomb

// Check my objdump -d file and Control + F to find “secret”. Here’s the parts that contain the word “secret”:

// 3 instances here:
0000000000400f03 <secret_phase>:
  400f03:	53                   	push   %rbx
  400f04:	e8 83 06 00 00       	callq  40158c <read_line>
  400f09:	ba 0a 00 00 00       	mov    $0xa,%edx              // set break point here to know when we enter the secret phase
  400f0e:	be 00 00 00 00       	mov    $0x0,%esi
  400f13:	48 89 c7             	mov    %rax,%rdi
  400f16:	e8 5d fc ff ff       	callq  400b78 <strtol@plt>
  400f1b:	89 c3                	mov    %eax,%ebx
  400f1d:	8d 43 ff             	lea    -0x1(%rbx),%eax
  400f20:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  400f25:	76 05                	jbe    400f2c <secret_phase+0x29>
  400f27:	e8 6a 05 00 00       	callq  401496 <explode_bomb>
  400f2c:	89 de                	mov    %ebx,%esi
  400f2e:	bf 80 39 60 00       	mov    $0x603980,%edi
  400f33:	e8 8f ff ff ff       	callq  400ec7 <fun7>
  400f38:	85 c0                	test   %eax,%eax
  400f3a:	74 05                	je     400f41 <secret_phase+0x3e>
  400f3c:	e8 55 05 00 00       	callq  401496 <explode_bomb>
  400f41:	bf 20 24 40 00       	mov    $0x402420,%edi
  400f46:	e8 6d fb ff ff       	callq  400ab8 <puts@plt>
  400f4b:	e8 91 04 00 00       	callq  4013e1 <phase_defused>
  400f50:	5b                   	pop    %rbx
  400f51:	c3                   	retq   

// 1 instance here:
00000000004013e1 <phase_defused>:
  4013e1:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  4013e8:	bf 01 00 00 00       	mov    $0x1,%edi
  4013ed:	e8 32 ff ff ff       	callq  401324 <send_msg>
  4013f2:	83 3d cf 29 20 00 06 	cmpl   $0x6,0x2029cf(%rip)        # 603dc8 <num_input_strings>
  4013f9:	0f 85 8f 00 00 00    	jne    40148e <phase_defused+0xad>
  4013ff:	48 8d 4c 24 38       	lea    0x38(%rsp),%rcx
  401404:	48 8d 54 24 3c       	lea    0x3c(%rsp),%rdx
  401409:	48 8d 44 24 40       	lea    0x40(%rsp),%rax
  40140e:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  401413:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
  401418:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  40141d:	48 8d 44 24 2c       	lea    0x2c(%rsp),%rax
  401422:	48 89 04 24          	mov    %rax,(%rsp)
  401426:	4c 8d 4c 24 30       	lea    0x30(%rsp),%r9
  40142b:	4c 8d 44 24 34       	lea    0x34(%rsp),%r8
  401430:	be 4e 25 40 00       	mov    $0x40254e,%esi      //1st address to check
  401435:	bf 30 3e 60 00       	mov    $0x603e30,%edi      //2nd address to check
  40143a:	b8 00 00 00 00       	mov    $0x0,%eax
  40143f:	e8 84 f6 ff ff       	callq  400ac8 <__isoc99_sscanf@plt>
  401444:	83 f8 07             	cmp    $0x7,%eax
  401447:	75 31                	jne    40147a <phase_defused+0x99>
  401449:	48 8d 7c 24 40       	lea    0x40(%rsp),%rdi
  40144e:	be 63 25 40 00       	mov    $0x402563,%esi      //3rd address to check
  401453:	e8 54 fe ff ff       	callq  4012ac <strings_not_equal>
  401458:	85 c0                	test   %eax,%eax
  40145a:	75 1e                	jne    40147a <phase_defused+0x99>
  40145c:	bf 98 26 40 00       	mov    $0x402698,%edi
  401461:	e8 52 f6 ff ff       	callq  400ab8 <puts@plt>
  401466:	bf c0 26 40 00       	mov    $0x4026c0,%edi
  40146b:	e8 48 f6 ff ff       	callq  400ab8 <puts@plt>
  401470:	b8 00 00 00 00       	mov    $0x0,%eax
  401475:	e8 89 fa ff ff       	callq  400f03 <secret_phase>
  40147a:	bf f8 26 40 00       	mov    $0x4026f8,%edi
  40147f:	e8 34 f6 ff ff       	callq  400ab8 <puts@plt>
  401484:	bf 28 27 40 00       	mov    $0x402728,%edi
  401489:	e8 2a f6 ff ff       	callq  400ab8 <puts@plt>
  40148e:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  401495:	c3                   	retq   

// Try to get into the secret phase first
break explode_bomb
break phase_6
run
I am for medical liability at the federal level.
1 2 3 5 8 13
1 o 195
60 3
eeeaaf
5 4 3 6 2 1

// check all these addresses:
(gdb) x/s 0x40254e
0x40254e:	 "%d %d %d %d %d %d %s"
(gdb) x/s 0x603e30
0x603e30 <input_strings+80>:	 "1 2 3 5 8 13"
(gdb) x/s 0x402563
0x402563:	 "AustinPowers"
// Nice! So I’m going to replace my phase 2 answer to be "1 2 3 5 8 13 AustinPowers” instead of just "1 2 3 5 8 13"

// Now my bombDefusingAns.txt looks like this:
I am for medical liability at the federal level.
1 2 3 5 8 13 AustinPowers
1 o 195
60 3
eeeaaf
5 4 3 6 2 1

// try this answer in gdb
(gdb) quit
(gdb) y
(gdb) break explode_bomb
Breakpoint 1 at 0x401496
(gdb) break *0x400f09
Breakpoint 2 at 0x400f09
(gdb) run bombDefusingAns.txt
Starting program: /w/home.05/ee/ugrad/jieyun/bomb150/bomb bombDefusingAns.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Curses, you've found the secret phase!
But finding it and solving it are quite different...

// Yay! Got in!
0              // input a random string first

Breakpoint 2, 0x0000000000400f09 in secret_phase ()
Missing separate debuginfos, use: debuginfo-install glibc-2.12-1.209.el6_9.2.x86_64
(gdb) disassemble
Dump of assembler code for function secret_phase:
   0x0000000000400f03 <+0>:	push   %rbx
   0x0000000000400f04 <+1>:	callq  0x40158c <read_line>
=> 0x0000000000400f09 <+6>:	mov    $0xa,%edx
   0x0000000000400f0e <+11>:	mov    $0x0,%esi
   0x0000000000400f13 <+16>:	mov    %rax,%rdi
   0x0000000000400f16 <+19>:	callq  0x400b78 <strtol@plt>
   0x0000000000400f1b <+24>:	mov    %eax,%ebx
   0x0000000000400f1d <+26>:	lea    -0x1(%rbx),%eax
   0x0000000000400f20 <+29>:	cmp    $0x3e8,%eax
   0x0000000000400f25 <+34>:	jbe    0x400f2c <secret_phase+41>
   0x0000000000400f27 <+36>:	callq  0x401496 <explode_bomb>
   0x0000000000400f2c <+41>:	mov    %ebx,%esi
   0x0000000000400f2e <+43>:	mov    $0x603980,%edi
   0x0000000000400f33 <+48>:	callq  0x400ec7 <fun7>               // calls function fun7.
   0x0000000000400f38 <+53>:	test   %eax,%eax                     // function fun7 needs to return 0.
   0x0000000000400f3a <+55>:	je     0x400f41 <secret_phase+62>
   0x0000000000400f3c <+57>:	callq  0x401496 <explode_bomb>
   0x0000000000400f41 <+62>:	mov    $0x402420,%edi
   0x0000000000400f46 <+67>:	callq  0x400ab8 <puts@plt>
   0x0000000000400f4b <+72>:	callq  0x4013e1 <phase_defused>
   0x0000000000400f50 <+77>:	pop    %rbx
   0x0000000000400f51 <+78>:	retq   
End of assembler dump.

// Check the registers right before calling fun7
(gdb) until *0x400f33
0x0000000000400f33 in secret_phase ()
(gdb) i r
rax            0x31	49
rbx            0x32	50
rcx            0x0	0
rdx            0x0	0
rsi            0x32	50
rdi            0x603980	6306176                               // one of the parameters sent into fun7, along with eax = 0
rbp            0x7fffffffe1d0	0x7fffffffe1d0
rsp            0x7fffffffe020	0x7fffffffe020
r8             0x380bf8ee40	240719031872
r9             0x380bd42380	240716620672
r10            0x32	50
r11            0x1999999999999999	1844674407370955161
r12            0x400c50	4197456
r13            0x7fffffffe1c0	140737488347584
r14            0x0	0
r15            0x0	0
rip            0x400f33	0x400f33 <secret_phase+48>
eflags         0x293	[ CF AF SF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

// Get into fun7 to take a look
(gdb) si
0x0000000000400ec7 in fun7 ()
(gdb) disassemble
Dump of assembler code for function fun7:
=> 0x0000000000400ec7 <+0>:	sub    $0x8,%rsp
   0x0000000000400ecb <+4>:	mov    $0xffffffff,%eax
   0x0000000000400ed0 <+9>:	test   %rdi,%rdi
   0x0000000000400ed3 <+12>:	je     0x400efe <fun7+55>
   0x0000000000400ed5 <+14>:	mov    (%rdi),%edx
   0x0000000000400ed7 <+16>:	cmp    %esi,%edx
   0x0000000000400ed9 <+18>:	jle    0x400ee8 <fun7+33>
   0x0000000000400edb <+20>:	mov    0x8(%rdi),%rdi
   0x0000000000400edf <+24>:	callq  0x400ec7 <fun7>
   0x0000000000400ee4 <+29>:	add    %eax,%eax
   0x0000000000400ee6 <+31>:	jmp    0x400efe <fun7+55>
   0x0000000000400ee8 <+33>:	mov    $0x0,%eax
   0x0000000000400eed <+38>:	cmp    %esi,%edx
   0x0000000000400eef <+40>:	je     0x400efe <fun7+55>
   0x0000000000400ef1 <+42>:	mov    0x10(%rdi),%rdi
   0x0000000000400ef5 <+46>:	callq  0x400ec7 <fun7>
   0x0000000000400efa <+51>:	lea    0x1(%rax,%rax,1),%eax
   0x0000000000400efe <+55>:	add    $0x8,%rsp
   0x0000000000400f02 <+59>:	retq   
End of assembler dump.

// check what this function returns with parameters 6306176 and 0
(gdb) p fun7(6306176, 0)
$1 = -16
// Need to get a return value of 0, not -16. Keep trying.
(gdb) p fun7(6306176, 1)
$2 = 0
// Got it the second try. So the answer should be the second parameter, which is 1. I know I didn’t spend time understanding what fun7 does and I got lucky with this brute force method for fun7.

// Try this in gdb
(gdb) kill
Kill the program being debugged? (y or n) y
(gdb) run bombDefusingAns.txt
Starting program: /w/home.05/ee/ugrad/jieyun/bomb150/bomb bombDefusingAns.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Curses, you've found the secret phase!
But finding it and solving it are quite different...
1

Breakpoint 2, 0x0000000000400f09 in secret_phase ()
(gdb) continue
Continuing.
Wow! You've defused the secret stage!
Congratulations! You've defused the bomb!
Your instructor has been notified and will verify your solution.

Program exited normally.
(gdb) 

// Success! Defused all 6 phases + a secret phase.
